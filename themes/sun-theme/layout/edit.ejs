<!--
  themes/your-theme/layout/edit.ejs

  说明（详细）：
  - 作用：在浏览器中提供一个简单的在线 Markdown 编辑器，用户输入文件路径和内容后，
    将通过 fetch 请求把内容提交到部署在 Vercel 上的 /api/savePost 接口，
    由后端将该内容写入 GitHub 仓库（通常是 Hexo 的 source 仓库），触发自动部署。
  - 风险提示（重要）：
    1. 当前页面允许“任何人”直接编辑并提交内容（无认证/授权），这会导致严重的安全/内容破坏风险。
       强烈建议在生产环境中增加登录认证（例如 OAuth / JWT / Cookie 登录）或至少一个简单的编辑密码，
       并在服务器端对权限进行校验。
    2. CORS 与 API Token：后端使用的 GITHUB_TOKEN 必须严格保存在服务器端（例如 Vercel 环境变量），
       绝不可放入前端代码或 public 仓库。前端请求只应发到你信任的后端域名（不要把后端设为开放的跨站点任意接受）。
    3. 输入校验与路径过滤：必须在后端额外校验 filePath，避免任意路径写入（只允许写入特定目录，如 source/_posts/）。
    4. 日志与审计：记录编辑者、时间、IP、提交信息（但避免记录 token），以便回滚或审计。
    5. 速率限制与滥用防护：为接口加入限流措施，防止垃圾数据或 DoS。
  - 建议功能改进（优先级）：
    1. 在前端加入“预览（Preview）”功能（解析 Markdown 为 HTML），编辑时可查看渲染效果。
    2. 在保存前自动检测并保留文章 Front-Matter（YAML）格式，并在覆盖时合并而非直接替换（避免丢失 metadata）。
    3. 在保存时展示 GitHub 返回的 commit URL 或 PR 链接（如果实现为 PR 模式）。
    4. 支持图片/附件上传（建议通过后端上传到仓库或使用第三方图床，并在 Markdown 中替换链接）。
    5. 使用 @octokit/rest 替代原生 fetch，以获得更可靠的错误处理与更友好的 API。
-->

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>编辑文章 | 我的博客</title>
  <style>
    /* 基础样式：设置字体和页面最大宽度，居中显示 */
    body { font-family: sans-serif; max-width: 800px; margin: 30px auto; }
    /* 文本编辑区域样式：设置宽度和高度 */
    textarea { width: 100%; height: 400px; margin-top: 10px; }
    /* 输入框样式：设置宽度、外边距和内边距 */
    input { width: 100%; margin-top: 10px; padding: 8px; }
    /* 按钮样式：设置外边距、内边距和鼠标样式 */
    button { margin-top: 10px; padding: 10px 20px; cursor: pointer; }
    /* 结果显示区域样式：设置外边距和文本颜色为绿色 */
    .result { margin-top: 10px; color: green; }
  </style>
</head>
<body>
  <h1>在线编辑文章</h1>
  <p>任何人都可以修改此博客内容（保存后自动部署）</p>

  <input id="filePath" placeholder="文件路径，例如：source/_posts/test.md">
  <textarea id="content" placeholder="在这里编辑 Markdown 内容..."></textarea>
  <button id="saveBtn">💾 保存到 GitHub</button>

  <div id="result" class="result"></div>

  <script>
    // 为保存按钮添加点击事件监听器
    document.getElementById("saveBtn").onclick = async () => {
      // 获取文件路径和内容的值，并去除路径的空白字符
      const filePath = document.getElementById("filePath").value.trim();
      const content = document.getElementById("content").value;
      
      // 检查文件路径和内容是否为空
      if (!filePath || !content) {
        alert("请输入文件路径和内容");
        return; // 阻止后续操作
      }

      // 更新结果区域，显示正在保存的状态
      document.getElementById("result").textContent = "正在保存，请稍候...";

      // 发送 POST 请求到 Vercel Serverless Function (API)
      const res = await fetch("https://blog-source-lime.vercel.app/api/savePost", {
        method: "POST", // HTTP 方法为 POST
        headers: { "Content-Type": "application/json" }, // 设置请求头，表明发送 JSON 数据
        body: JSON.stringify({ // 将数据转换为 JSON 字符串作为请求体
          filePath, // 文件路径
          content,  // 文章内容
          message: `用户在线更新：${filePath}`, // GitHub commit 消息
        }),
      });

      // 解析 API 返回的 JSON 数据
      const data = await res.json();
      
      // 根据 API 返回的 success 字段判断操作结果
      if (data.success) {
        // 保存成功，更新结果提示
        document.getElementById("result").textContent = "✅ 保存成功！博客将自动更新。";
      } else {
        // 保存失败，显示错误信息
        document.getElementById("result").textContent = "❌ 发生错误：" + data.error;
      }
    };
    
    // 可选扩展（TODO）：
    // - 自动保存草稿（localStorage）以防止浏览器崩溃后数据丢失。
    // - 编辑冲突提示：在提交前可先调用 GET /contents/{filePath} 读取最新 sha，判断是否发生变化并提示用户合并。
    // - 在提交前进行 Front-Matter 校验并提醒缺失必需字段（title/date/categories）。
    // - 如果希望更安全，可把保存动作改为：创建 Pull Request（后端用 GitHub API 创建分支+提交+PR），由管理员合并。
  </script>
</body>
</html>